<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Bonway">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Bonway">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bonway">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Bonway</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bonway</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/20/iPhone-X主流APP适配情况/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bonway">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bonway">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/20/iPhone-X主流APP适配情况/" itemprop="url">iPhone-X主流APP适配情况</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-20T14:23:26+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于iPhone一张脸用了三年这件事，最开心的大概就是那些手机APP设计者，毕竟一个模板可以用三年以上，并且不用再为那些长短不一的屏幕去不断的更改自己的设计方案，简直是一劳永逸。</p>
<p>但iPhone X的出现却打破了他们的平静，那朵小刘海不仅折磨疯了一大票强迫症患者，更是让程序员们抓耳挠腮。</p>
<p>而现在距离iPhone X面世已经过去了两周，可以看到绝大多数我们常用的APP都已经针对异形屏完成了适配，但其中有些新的设计好像也并没有那么走心。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-28956611177c8451..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.jpg" title="1511339974822459.jpg"></p>
<p>bilibili：日语不过N1也敢看B站？</p>
<p>就适配速度而言，B站绝对算得上是国内众APP中的第一梯队，在iPhone X发售后的第三天便完成了更新，但是现在两周时间过去，之前那些没解决的问题也依然还没解决。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-52968333f9e22ba3..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.jpg" title="1511339987197633.jpg"></p>
<p>bilibili的首页完完整整的填满了整个屏幕，但大概是为了能在标准排版下尽可能多的显示首页内容，顶端菜单栏的空间设计十分紧促，所有标签全都如胶似漆的与小刘海贴了个严丝合缝。</p>
<p>如果说专栏标签可以通过左右滑动页面来进行切换的话，那么一旁的搜索键便几乎没有了可操作的空间，普通的点按手势几乎完全无法准确的开启搜索功能，多次尝试后才终于得以在极小的可识别空间内打开搜索栏。</p>
<p><strong>而现在已经两周过去，B站依然没有对此进行修复，每次使用搜索功能都让我想到了之前小心翼翼的抠电阻屏按键的手感。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-316fc2835fa0d046..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.jpg" title="1511340013866653.jpg"></p>
<p>而作为bilibili的主营业务，在引进类的原声动画播放时，<strong>却出现了自制字幕被Home Indicator，也就是屏幕下方的那根长条遮挡的现象，</strong>看来日语不过N1，英语没有专八简直没有办法在B站看原声剧了。</p>
<p>其实这一问题理应非常容易解决，比如B站自行加入画面上下颠倒的功能，因为如果使用苹果自带的屏幕重力感应来翻转屏幕，那么下方那根长条也会跟随屏幕翻转而移动。</p>
<p>或者像隔壁的优酷一样，将自制字幕设计到避开Home Indicator的位置。总之这是一个非常容易解决并且确实已经影响到了观看体验的问题，但是bilibili却并没有做出应对。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-4a846007aef653a6..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.jpg" title="1511340096285890.jpg"></p>
<p>bilibili播放日番《阿松》</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-4a25c8abcb2faa59..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.jpg" title="1511340108794404.jpg"></p>
<p>优酷播放日番《阿松》</p>
<p>《王者荣耀》：花钱，你也不会变更强</p>
<p>《王者荣耀》对于iPhone X的适配速度并不算快，但它确实针对“小刘海”做出了很多设计上的改动，例如将好友栏以及道具购买按键向屏幕中心平移以避开异形屏的黑边。</p>
<p>但本以为适配后iPhone X可以像Galaxy Note8一样获得相比其他手机更大的视野，结果企鹅明显没有想让你获得这一特权。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-09c35e76851b4573..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.jpg" title="1511340135137712.jpg"></p>
<p>在《王者荣耀》的游戏战斗场景中<strong>，腾讯将屏幕两侧加入了渐变黑边，来遮挡多出的可显示面积，</strong>所以在进行游戏时相比iPhone 7Plus或者iPhone 8Plus这类手机，iPhone X不会获得更多的可视面积，花了更多的钱却没让我变更强，这真是太不符合腾讯的作风了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-f02e0f7cfc978d86..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.jpg" title="1511340156288787.jpg"></p>
<p>同时大多数的侧边菜单栏都为避开屏幕“刘海”做了拉长处理，但仔细翻阅，还是能找到部分未能进行适配的菜单，不知道《王者荣耀》何时会进行修复。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-86f3b3cd6554b293..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.jpg" title="1511340168531053.jpg"></p>
<p>《阴阳师》：那些消失的队友</p>
<p>阴阳师的适配速度并不算快，它在iPhone X上市第三周周五的日常维护中才加入了对于异形屏的适配，作为一个对视野和侧边功能键没有太多需求的游戏，<strong>阴阳师其实也只需要简单的将显示面积拉大，占满整个屏幕即可。但在某些细节之处却能看到，阴阳师并没有做到尽善尽美。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-c3aaa06c4bff6cb6..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.jpg" title="1511340186709068.jpg"></p>
<p>比如在与世界服务器玩家组队时，左侧的队友栏被完全遮盖，但在一部分其他组队功能中，左侧的队友栏又会如同《王者荣耀》一样避开“刘海”，不知道网易是否遗漏了某部分需要进行改动的设计。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-a535a1821194fdc2..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Sb04f28c1-2be7-45f7-8f7f-3a9283b9d073.jpg" title="1511340236981504.jpg"></p>
<p>Chrome：令人窒息的额头</p>
<p>大部分APP为了适配iPhone X，都会选择直接将额头处留白，让手机的“刘海”自行填充留白处，而Google的Chorme浏览器也正是这么做了。</p>
<p>但问题在于，当横置手机时，页面的额头却依然保留了下来，在屏幕顶端留下了大约1cm的空白，最令人发指的是它并不会随着网址输入栏的隐藏而消失。</p>
<p>要知道原本在将屏幕横置后，页面的高度就不会特别理想，而Chrome的留白进一步压榨了可视面积，让页面的可显示内容进一步缩水，而隔壁的Firefox在这方面的处理就要更好一些。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-eea41246a3e1db35..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.jpg" title="1511340249992498.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-df34ed64d0ecc1b8..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.jpg" title="1511340260536131.jpg"></p>
<p>Chrome横置页面打开网页</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-6b14441cdeabcb0a..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.jpg" title="1511340296333732.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-a734a7da7d50c74c..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.jpg" title="1511340308697616.jpg"></p>
<p>Firefox横置页面打开网页</p>
<p>支付宝：面部支付仍未加入</p>
<p>支付宝对于iPhone X的适配速度还算令人满意，而且这样一个功能性APP，我大概每天只会用它来扫二维码，所以屏幕的适配与否并没对我的日常使用造成什么影响。</p>
<p>但苹果手机家族中，iPhone X独有的Face ID已经过去了两周还未能应用在支付宝中，没有对比就没有伤害，隔壁主营网络通讯顺带做了支付功能的微信，几乎是第一时间便支持了面容支付。据说支付宝正在内测Face ID的应用支持，但不知何时才能上线呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-4aa6a09f311f4d17..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png" title="1511340330476556.png"></p>
<p>建设银行：泪流满面的更新速度</p>
<p>建设银行APP的更新是令我始料未及的，作为曾经的iPhone6 Plus第一批次用户，建设银行用了一年多的时间才完成了对大屏iPhone手机的适配，所以此次对于新手机的支持速度简直让人泪流满面。</p>
<p>不过在新版建设银行APP中，虽然没有对我的使用造成什么困扰，但APP首页顶端怎么看都像是把小屏版本界面加了同色调的额头而已，底部处理则更为直接，看上去如同未进行适配后直接嵌入的设计。</p>
<p>但在其他部分界面的设计下，却又让我确确实实的感受到我是在使用一台没有下巴的iPhone X，使用体验十分多变。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-86f3c0f891820fe7..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.jpg" title="1511340371842310.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-d7d0b4ac91f3f805..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.jpg" title="1511340387464090.jpg"></p>
<p>不过无论如何我还是要给建设银行点个赞，因为它是目前与某神秘组织相关的APP中，唯一一个完成对iPhone X适配的。隔壁的工、农、商三行再加上12306，目前还都只是嵌入小屏幕模板的设计，按照他们一贯的更新速度，想要完成适配大概也要等到明年了。</p>
<p>其实从各家APP的适配速度来看，能明显感受到iPhone X的小刘海确实给那些设计师和程序员们造成了不小的困扰，也许大部分APP只需要拉长额头并以相同的颜色进行顶部填充即可。</p>
<p>但还有一部分APP却需要更细心的调整，甚至是定制化的改动，而在这部分调整中，难免会出现种种细节方面的问题。</p>
<p>但现在距离iPhone X面世已经过去了超过两周时间，一部分APP出现的问题早已暴露，甚至还暴露的非常明显，不知道想要完美适配新手机，这些APP们还要让我们等多久呢？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/iOS面试题：腾讯一、二、三面以及参考思路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bonway">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bonway">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/iOS面试题：腾讯一、二、三面以及参考思路/" itemprop="url">iOS面试题：腾讯一、二、三面以及参考思路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T14:23:26+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><strong>使用了第三方库, 有看他们是怎么实现的吗？</strong></li>
</ol>
<p>例：SD、YY、AFN、MJ等！</p>
<p><strong><1>.SD为例：</1></strong></p>
<p><code>1.入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。</code></p>
<p><code>2.进入 SDWebImageManagerdownloadWithURL:delegate:options:userInfo:交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.</code></p>
<p><code>3.先从内存图片缓存查找是否有图片如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。</code></p>
<p><code>4.SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。</code></p>
<p><code>5.如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。</code></p>
<p><code>6.根据 URLKey 在硬盘缓存目录下尝试读取图片文件。</code></p>
<p><code>这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。</code></p>
<p><code>7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。</code></p>
<p><code>8.如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。</code></p>
<p><code>9.共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。</code></p>
<p><code>10.图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。</code></p>
<p><code>11.connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。</code></p>
<p><code>12.connectionDidFinishLoading: 数据下载完成后交 SDWebImageDecoder 做图片解码处理。</code></p>
<p><code>13.图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。</code></p>
<p><code>14.在主线程 notifyDelegateOnMainThreadWithInfo:宣告解码完成，</code></p>
<p><code>imageDecoder:didFinishDecodingImage:userInfo回调给 SDWebImageDownloader。</code></p>
<p><code>15.imageDownloader:didFinishWithImage:回调给 SDWebImageManager 告知图片下载完成。</code></p>
<p><code>16.通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。</code></p>
<p><code>17.将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。</code></p>
<p><code>18.SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存</code></p>
<p><code>应用结束的时候清理过期图片。</code></p>
<p><code>19.SDWI 也提供了 UIButton+WebCache 和MKAnnotationView+WebCache，方便使用。</code></p>
<p><code>20.SDWebImagePrefetcher 可以预先下载图片，方便后续使用。</code></p>
<p><strong>2.强连通分量了解嘛？</strong></p>
<p><strong>概念：</strong></p>
<p>有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。</p>
<p><strong>定义：</strong></p>
<p>有向图强连通分量：</p>
<p>在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点强连通（strongly connected）。</p>
<p>如果有向图G的每两个顶点都强连通，则称G是一个强连通图。</p>
<p>非强连通图有向图的极大强连通子图，成为强连通分量（strongly connected components）。</p>
<p>下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达，{5}，{6}也分别是两个强连通分量。<br><img src="http://upload-images.jianshu.io/upload_images/10991770-235e741680a0d4c4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.jpg"></p>
<p>直接根据定义，用双向遍历取交际的方法求强连通分量，时间复杂度为O（N^2+M）。更好的方法是Kosaraju算法或者Tarjan算法两者的时间复杂度都是O（N+M）。本文介绍的是Tarjan算法。</p>
<p><strong>算法原理：（Tarjan）</strong></p>
<p>need-to-insert-img</p>
<p>Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一颗子树。</p>
<p>搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以盘对栈顶到栈中的节点是否为一个强连通分量。</p>
<p>定义DFN（u）为节点u搜索的次序编号（时间戳）。Low（u）为u或者u的子树能够追溯到的最早的栈中的节点的次序号。</p>
<p>由定义可以得出：</p>
<p>Low（u）= Min { DFN（u）， Low（v）} （（u，v）为树枝边，u为v的父节点DFN（v），（u，v）为指向栈中节点的后向边（非横叉边））</p>
<p>当DFN（u）=Low（u）时，以u为根的搜索子树上所有节点是一个强连通分量。</p>
<p><strong>3.遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？</strong></p>
<p><strong>可能造成tableView卡顿的原因有：</strong></p>
<p><strong>1.最常用的就是cell的重用， 注册重用标识符</strong></p>
<p>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell</p>
<p>如果有很多数据的时候，就会堆积很多cell。</p>
<p>如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell</p>
<p><strong>2.避免cell的重新布局</strong></p>
<p>cell的布局填充等操作 比较耗时，一般创建时就布局好</p>
<p>如可以将cell单独放到一个自定义类，初始化时就布局好</p>
<p><strong>3.提前计算并缓存cell的属性及内容</strong></p>
<p>当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度</p>
<p>而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</p>
<p><strong>4.减少cell中控件的数量</strong></p>
<p>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，</p>
<p>不适用的可以先隐藏</p>
<p><strong>5.不要使用ClearColor，无背景色，透明度也不要设置为0</strong></p>
<p>渲染耗时比较长</p>
<p><strong>6.使用局部更新</strong></p>
<p>如果只是更新某组的话，使用reloadSection进行局部更</p>
<p><strong>7.加载网络数据，下载图片，使用异步加载，并缓存</strong></p>
<p><strong>8.少使用addView 给cell动态添加view</strong></p>
<p><strong>9.按需加载cell，cell滚动很快时，只加载范围内的cell</strong></p>
<p><strong>10.不要实现无用的代理方法，tableView只遵守两个协议</strong></p>
<p><strong>11.缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可</strong></p>
<p><strong>12.不要做多余的绘制工作。</strong>在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。</p>
<p><strong>13.预渲染图像。</strong>当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕；</p>
<p><strong>14.使用正确的数据结构来存储数据。</strong></p>
<p><strong>4.M、V、C相互通讯规则你知道的有哪些？</strong></p>
<p><strong>MVC 是一种设计思想，一种框架模式，是一种把应用中所有类组织起来的策略，它把你的程序分为三块，分别是：</strong></p>
<p><strong>M（Model</strong>）：实际上考虑的是“什么”问题，你的程序本质上是什么，独立于 UI 工作。是程序中用于处理应用程序逻辑的部分，通常负责存取数据。</p>
<p>C（Controller）：控制你 Model 如何呈现在屏幕上，当它需要数据的时候就告诉 Model，你帮我获取某某数据；当它需要 UI 展示和更新的时候就告诉 View，你帮我生成一个 UI 显示某某数据，是 Model 和 View 沟通的桥梁。</p>
<p><strong>V（View）</strong>：Controller 的手下，是 Controller 要使用的类，用于构建视图，通常是根据 Model 来创建视图的。</p>
<p><strong>要了解 MVC 如何工作，首先需要了解这三个模块间如何通信。</strong></p>
<p>MVC通信规则</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-9e516f77f5f2cfef..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.jpg" title="1511752329535960.jpg"></p>
<p><strong>Controller to Model</strong></p>
<p>可以直接单向通信。Controller 需要将 Model 呈现给用户，因此需要知道模型的一切，还需要有同 Model 完全通信的能力，并且能任意使用 Model 的公共 API。</p>
<p><strong>Controller to View</strong></p>
<p>可以直接单向通信。Controller 通过 View 来布局用户界面。</p>
<p><strong>Model to View</strong></p>
<p>永远不要直接通信。Model 是独立于 UI 的，并不需要和 View 直接通信，View 通过 Controller 获取 Model 数据</p>
<p><strong>View to Controller</strong></p>
<p>View 不能对 Controller 知道的太多，因此要通过间接的方式通信。</p>
<p>Target</p>
<p>action。首先 Controller 会给自己留一个 target，再把配套的 action 交给 View 作为联系方式。那么 View</p>
<p>接收到某些变化时，View 就会发送 action 给 target 从而达到通知的目的。这里 View 只需要发送</p>
<p>action，并不需要知道 Controller 如何去执行方法。</p>
<p>代理。有时候 View 没有足够的逻辑去判断用户操作是否符合规范，他会把判断这些问题的权力委托给其他对象，他只需获得答案就行了，并不会管是谁给的答案。</p>
<p>DataSoure。View 没有拥有他们所显示数据的权力，View 只能向 Controller 请求数据进行显示，Controller 则获取 Model 的数据整理排版后提供给 View。</p>
<p>Model 访问 Controller</p>
<p>同样的 Model 是独立于 UI 存在的，因此无法直接与 Controller 通信，但是当 Model 本身信息发生了改变的时候，会通过下面的方式进行间接通信。</p>
<p><strong>Notification &amp; KVO一种类似电台的方法，Model 信息改变时会广播消息给感兴趣的人 ，只要 Controller 接收到了这个广播的时候就会主动联系 Model，获取新的数据并提供给 View。</strong></p>
<p>从上面的简单介绍中我们来简单概括一下 MVC 模式的优点。</p>
<p>1.低耦合性</p>
<p>2.有利于开发分工</p>
<p>3.有利于组件重用</p>
<p>4.可维护性</p>
<p><strong>5.NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?</strong></p>
<p><strong>1.不准</strong></p>
<p><strong>2.不准的原因如下：</strong></p>
<p>1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。</p>
<p>2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。</p>
<p>当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。</p>
<p>PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。</p>
<p><strong>方法一：</strong></p>
<p>1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。</p>
<p>self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];</p>
<p>[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</p>
<p>2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；<br><code>- (void)timerMethod2 {</code><br><code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];</code><br><code>[thread start];</code><br><code>}</code></p>
<p><code>- (void)newThread</code></p>
<p><code>{</code></p>
<p><code>@autoreleasepool</code></p>
<p>  <code>{</code><br><code>[NSTimer scheduledTimerWithTimeInterval:``1.0</code> <code>target:self selector:@selector(showTime) userInfo:nil repeats:YES];</code><br><code>[[NSRunLoop currentRunLoop] run];</code><br><code>}</code></p>
<p><code>}</code><br>总结：</p>
<p>一开始的时候系统就为我们将主线程的main runloop隐式的启动了。<br>在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop</p>
<p><strong>方法二：</strong></p>
<p><strong>使用示例</strong></p>
<p>使用mach内核级的函数可以使用mach_absolute_time()获取到CPU的tickcount的计数值，可以通过”mach_timebase_info”函数获取到纳秒级的精确度 。然后使用mach_wait_until(uint64_t deadline)函数，直到指定的时间之后，就可以执行指定任务了。</p>
<p>关于数据结构mach_timebase_info的定义如下：</p>
<p><code>struct mach_timebase_info {uint32_t numer;uint32_t denom;};</code></p>
<p><code>#include</code></p>
<p><code>#include</code></p>
<p><code>static</code> <code>const</code> <code>uint64_t NANOS_PER_USEC = 1000ULL;</code></p>
<p><code>static</code> <code>const</code> <code>uint64_t NANOS_PER_MILLISEC = 1000ULL * NANOS_PER_USEC;</code></p>
<p><code>static</code> <code>const</code> <code>uint64_t NANOS_PER_SEC = 1000ULL * NANOS_PER_MILLISEC;</code></p>
<p><code>static</code> <code>mach_timebase_info_data_t timebase_info;</code></p>
<p><code>static</code> <code>uint64_t nanos_to_abs(uint64_t nanos) {</code></p>
<p><code>return</code> <code>nanos * timebase_info.denom / timebase_info.numer;</code></p>
<p><code>}</code></p>
<p><code>void</code> <code>example_mach_wait_until(``int</code> <code>seconds)</code></p>
<p><code>{</code></p>
<p><code>mach_timebase_info(&amp;timebase_info);</code></p>
<p><code>uint64_t time_to_wait = nanos_to_abs(seconds * NANOS_PER_SEC);</code></p>
<p><code>uint64_t now = mach_absolute_time();</code></p>
<p><code>mach_wait_until(now + time_to_wait);</code></p>
<p><code>}</code></p>
<p> |</p>
<p><strong>方法三：直接使用GCD替代！</strong></p>
<p><strong><img src="http://upload-images.jianshu.io/upload_images/10991770-cf52a7c313d0e375..gif?imageMogr2/auto-orient/strip" alt="2.gif" title="1511752533900159.gif"></strong> </p>
<p><strong>iOS面试题：腾讯二面以及参考思路：</strong></p>
<ol>
<li><strong>编译过程做了哪些事情？</strong></li>
</ol>
<p>1.C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在CPU上执行，所以执行效率较高。</p>
<p>iOS开发目前的常用语言是：Objective和Swift。二者都是编译语言，换句话说都是需要编译才能执行的。二者的编译都是依赖于Clang + LLVM. OC和Swift因为原理上大同小异，知道一个即可！</p>
<p><strong>iOS编译</strong></p>
<p>不管是OC还是Swift，都是采用Clang作为编译器前端，LLVM(Low level vritual machine)作为编译器后端。所以简单的编译过程如图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-c2e90bcd7737a336..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.jpg" title="1511753444245759.jpg"></p>
<p><strong>编译器前端</strong></p>
<p>编译器前端的任务是进行：语法分析，语义分析，生成中间代码(intermediate representation )。在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-5e3b029634165a15..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.jpg" title="1511753469995468.jpg"></p>
<p><strong>编译器后端</strong></p>
<p>编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。iOS的编译过程，后端的处理如下</p>
<p><strong>LVVM优化器会进行BitCode的生成，链接期优化等等</strong></p>
<p><strong><img src="http://upload-images.jianshu.io/upload_images/10991770-f1936f7a6fad0410..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.jpg" title="1511753575393142.jpg"></strong> </p>
<p><strong>LLVM机器码生成器会针对不同的架构，比如arm64等生成不同的机器码。</strong></p>
<p><strong><img src="http://upload-images.jianshu.io/upload_images/10991770-d5c4a5a4df2f2d09..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.jpg" title="1511753730633498.jpg"></strong> </p>
<p><strong>执行一次XCode build的流程</strong></p>
<p>当你在XCode中，选择build的时候（快捷键command+B），会执行如下过程</p>
<p>编译信息写入辅助文件，创建编译后的文件架构(name.app)</p>
<p>处理文件打包信息，例如在debug环境下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-c3cec610e905b9da..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.jpg" title="1511753750653017.jpg"></p>
<p>执行CocoaPod编译前脚本</p>
<p>例如对于使用CocoaPod的工程会执行CheckPods Manifest.lock</p>
<p>编译各个.m文件，使用CompileC和clang命令。</p>
<p><strong>编译各个.m文件，使用CompileC和clang命令。</strong> </p>
<p><code>1.CompileC ClassName.o ClassName.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</code></p>
<p><code>2.export.US-ASCII</code></p>
<p><code>3.export PATH = &quot;...&quot;</code></p>
<p><code>4.clang-x objective-c -arch x86_64 -fmessage-length=0</code> <code>-fobjc-arc...</code></p>
<p><code>-Wno-missing-field-initializers ... -DDEBUG=``1</code> <code>... -isysroot</code></p>
<p><code>iPhoneSimulator10.``1``.sdk -fasm-blocks ... -I 上文提到的文件 -F 所需要的Framework-iquote 所需要的Framework ... -c ClassName.c -o ClassName.o</code></p>
<p><strong>通过这个编译的命令，我们可以看到</strong></p>
<p><strong><img src="http://upload-images.jianshu.io/upload_images/10991770-76e54938dd128070..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.jpg" title="1511753787248683.jpg"></strong> </p>
<p><strong>2.字典大致实现原理；</strong></p>
<p><strong>一：字典原理</strong></p>
<p>NSDictionary（字典）是使用hash表来实现key和value之间的映射和存储的</p>
<p>方法：- (void)setObject:(id)anObject forKey:(id)aKey;</p>
<p>Objective-C中的字典NSDictionary底层其实是一个哈希表</p>
<p><strong>二：哈希原理</strong></p>
<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<p><strong>哈希概念</strong>:哈希表的本质是一个数组，数组中每一个元素称为一个箱子(bin)，箱子中存放的是键值对。</p>
<p><strong>三：哈希存储过程</strong></p>
<p><strong>1.根据 key 计算出它的哈希值 h。</strong></p>
<p><strong>2.假设箱子的个数为 n，那么这个键值对应该放在第 (h % n) 个箱子中。</strong></p>
<p><strong>3.如果该箱子中已经有了键值对，就使用开放寻址法或者拉链法解决冲突。</strong></p>
<p>在使用拉链法解决哈希冲突时，每个箱子其实是一个链表，属于同一个箱子的所有键值对都会排列在链表中。</p>
<p><strong>哈希表还有一个重要的属性</strong>: 负载因子(load factor)，它用来衡量哈希表的空/满程度，一定程度上也可以体现查询的效率，计算公式为:</p>
<p><strong>负载因子 = 总键值对数 / 箱子个数</strong></p>
<p>负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，哈希表将自动扩容。</p>
<p>哈希表在自动扩容时，一般会创建两倍于原来个数的箱子，因此即使 key 的哈希值不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。</p>
<p>哈希表的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。</p>
<p><strong>基于以上总结，细心的朋友可能会发现哈希表的两个问题:</strong></p>
<p><strong>1.如果哈希表中本来箱子就比较多，扩容时需要重新哈希并移动数据，性能影响较大。</strong></p>
<p><strong>2.如果哈希函数设计不合理，哈希表在极端情况下会变成线性表，性能极低。</strong></p>
<p><strong>3.block和函数指针的理解；</strong></p>
<p><strong>相似点：</strong></p>
<p>函数指针和Block都可以实现回调的操作，声明上也很相似，实现上都可以看成是一个代码片段。</p>
<p>函数指针类型和Block类型都可以作为变量和函数参数的类型。（typedef定义别名之后，这个别名就是一个类型）</p>
<p><strong>不同点：</strong></p>
<p>函数指针只能指向预先定义好的函数代码块（可以是其他文件里面定义，通过函数参数动态传入的），函数地址是在编译链接时就已经确定好的。</p>
<p>Block本质是Objective-C对象，是NSObject的子类，可以接收消息。</p>
<p>函数里面只能访问全局变量，而Block代码块不光能访问全局变量，还拥有当前栈内存和堆内存变量的可读性（当然通过__block访问指示符修饰的局部变量还可以在block代码块里面进行修改）。</p>
<p>从内存的角度看，函数指针只不过是指向代码区的一段可执行代码，而block实际上是程序运行过程中在栈内存动态创建的对象，可以向其发送copy消息将block对象拷贝到堆内存，以延长其生命周期。</p>
<p><strong>4.一般开始做一个项目，你的架构是如何思考的？</strong></p>
<p><a href="https://link.jianshu.com/?t=https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="external">参考文章一</a></p>
<p><a href="https://link.jianshu.com/?t=https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="external">参考文章二</a></p>
<p><strong>5.你了解的UIKit结构？</strong></p>
<p><strong><img src="http://upload-images.jianshu.io/upload_images/10991770-3ac4706a654b84c0..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.jpg" title="1511753924688843.jpg"></strong> </p>
<p><strong>这题应该是在你回答的基础之上，进行二次提问，主要还是看你的基础！</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/08/iOS-WKWebView适配/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bonway">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bonway">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/08/iOS-WKWebView适配/" itemprop="url">iOS WKWebView适配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-08T18:02:22+08:00">
                2016-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####1. ios9以前版本读取本地HTML的问题</p>
<p>当使用loadRequest来读取本地的HTML时，WKWebView是无法读取成功的，后台会出现如下的提示：<br><figure class="highlight plain"><figcaption><span>not create a sandbox extension for / ```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">原因是WKWebView是不允许通过loadRequest的方法来加载本地根目录的HTML文件。</div><div class="line">而在iOS9的SDK中加入了以下方法来加载本地的HTML文件：</div><div class="line">```[WKWebView loadFileURL:allowingReadAccessToURL:]</div></pre></td></tr></table></figure></p>
<p>但是在iOS9以下的版本是没提供这个便利的方法的。以下为解决方案的思路，就是在iOS9以下版本时，先将本地HTML文件的数据copy到tmp目录中，然后再使用loadRequest来加载。但是如果在HTML中加入了其他资源文件，例如js，css，image等必须一同copy到temp中。这个是最蛋疼的事情了。</p>
<p>解决方法如下<br>1.Objective-C：</p>
<p>//将文件copy到tmp目录<br><figure class="highlight plain"><figcaption><span>(NSURL *)fileURLForBuggyWKWebView8:(NSURL *)fileURL &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    NSError *error = nil;</div><div class="line">    if (!fileURL.fileURL || ![fileURL checkResourceIsReachableAndReturnError:&amp;error]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    // Create &quot;/temp/www&quot; directory</div><div class="line">    NSFileManager *fileManager= [NSFileManager defaultManager];</div><div class="line">    NSURL *temDirURL = [[NSURL fileURLWithPath:NSTemporaryDirectory()] URLByAppendingPathComponent:@&quot;www&quot;];</div><div class="line">    [fileManager createDirectoryAtURL:temDirURL withIntermediateDirectories:YES attributes:nil error:&amp;error];</div><div class="line">    </div><div class="line">    NSURL *dstURL = [temDirURL URLByAppendingPathComponent:fileURL.lastPathComponent];</div><div class="line">    // Now copy given file to the temp directory</div><div class="line">    [fileManager removeItemAtURL:dstURL error:&amp;error];</div><div class="line">    [fileManager copyItemAtURL:fileURL toURL:dstURL error:&amp;error];</div><div class="line">    // Files in &quot;/temp/www&quot; load flawlesly :)</div><div class="line">    return dstURL;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//调用逻辑<br><figure class="highlight plain"><figcaption><span>*path = [[NSBundle mainBundle] pathForResource:@"indexoff" ofType:@"html"];</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">if(path)&#123;</div><div class="line">    if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 9.0) &#123;</div><div class="line">        // iOS9. One year later things are OK.</div><div class="line">        NSURL *fileURL = [NSURL fileURLWithPath:path];</div><div class="line">        [self.webView loadFileURL:fileURL allowingReadAccessToURL:fileURL];</div><div class="line">    &#125; else &#123;</div><div class="line">        // iOS8. Things can be workaround-ed</div><div class="line">        //   Brave people can do just this</div><div class="line">        //   fileURL = try! pathForBuggyWKWebView8(fileURL)</div><div class="line">        //   webView.loadRequest(NSURLRequest(URL: fileURL))</div><div class="line">        </div><div class="line">        NSURL *fileURL = [self.fileHelper fileURLForBuggyWKWebView8:[NSURL fileURLWithPath:path]];</div><div class="line">        NSURLRequest *request = [NSURLRequest requestWithURL:fileURL];</div><div class="line">        [self.webView loadRequest:request];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.Swift</p>
<p>//将文件copy到tmp目录<br><figure class="highlight plain"><figcaption><span>fileURLForBuggyWKWebView8(fileURL: NSURL) throws -> NSURL &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">    // Some safety checks</div><div class="line">    var error:NSError? = nil;</div><div class="line">    if (!fileURL.fileURL || !fileURL.checkResourceIsReachableAndReturnError(&amp;error)) &#123;</div><div class="line">        throw error ?? NSError(</div><div class="line">            domain: &quot;BuggyWKWebViewDomain&quot;,</div><div class="line">            code: 1001,</div><div class="line">            userInfo: [NSLocalizedDescriptionKey: NSLocalizedString(&quot;URL must be a file URL.&quot;, comment:&quot;&quot;)])</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Create &quot;/temp/www&quot; directory</div><div class="line">    let fm = NSFileManager.defaultManager()</div><div class="line">    let tmpDirURL = NSURL.fileURLWithPath(NSTemporaryDirectory()).URLByAppendingPathComponent(&quot;www&quot;)</div><div class="line">    try! fm.createDirectoryAtURL(tmpDirURL, withIntermediateDirectories: true, attributes: nil)</div><div class="line"></div><div class="line">    // Now copy given file to the temp directory</div><div class="line">    let dstURL = tmpDirURL.URLByAppendingPathComponent(fileURL.lastPathComponent!)</div><div class="line">    let _ = try? fileMgr.removeItemAtURL(dstURL)</div><div class="line">    try! fm.copyItemAtURL(fileURL, toURL: dstURL)</div><div class="line"></div><div class="line">    // Files in &quot;/temp/www&quot; load flawlesly :)</div><div class="line">    return dstURL</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//方法调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var filePath = NSBundle.mainBundle().pathForResource(&quot;file&quot;, ofType: &quot;pdf&quot;)</div><div class="line"></div><div class="line">    if #available(iOS 9.0, *) &#123;</div><div class="line">        // iOS9. One year later things are OK.</div><div class="line">        webView.loadFileURL(fileURL, allowingReadAccessToURL: fileURL)</div><div class="line">    &#125; else &#123;</div><div class="line">        // iOS8. Things can be workaround-ed</div><div class="line">        //   Brave people can do just this</div><div class="line">        //   fileURL = try! pathForBuggyWKWebView8(fileURL)</div><div class="line">        //   webView.loadRequest(NSURLRequest(URL: fileURL))</div><div class="line">        do &#123;</div><div class="line">            fileURL = try fileURLForBuggyWKWebView8(fileURL)</div><div class="line">            webView.loadRequest(NSURLRequest(URL: fileURL))</div><div class="line">        &#125; catch let error as NSError &#123;</div><div class="line">            print(&quot;Error: &quot; + error.debugDescription)</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>WKWebView - WKNavigationDelegate使用<br>特别提醒一点，在使用以下delegate的方法时<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler</div><div class="line">需执行decisionHandler的block。</div><div class="line"></div><div class="line">例如：</div><div class="line"></div><div class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</div><div class="line">    </div><div class="line">    NSURLRequest *request = navigationAction.request;</div><div class="line">    WMPageActionType actionType = ActionTypeNone;</div><div class="line">    WKNavigationActionPolicy actionPolicy = WKNavigationActionPolicyAllow;</div><div class="line">    if([request.URL.absoluteString hasPrefix:OC_CLOSE_REQUEST])&#123;</div><div class="line">        actionType = ActionTypeClose;</div><div class="line">        actionPolicy = WKNavigationActionPolicyCancel;</div><div class="line">    &#125;</div><div class="line">    if(self.actionDelegate &amp;&amp; [self.actionDelegate respondsToSelector:@selector(webView:action:type:)]) &#123;</div><div class="line">        [self.actionDelegate webView:webView action:navigationAction type:actionType];</div><div class="line">    &#125;</div><div class="line">   //这句是必须加上的，不然会异常</div><div class="line">    decisionHandler(actionPolicy);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>3.WKWebView-JS执行方法</p>
<p>WKWebView JS执行方法与UIWebView不一样了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^)(id, NSError *))completionHandler;  </div><div class="line">completionHandler 拥有两个参数，一个是返回错误，一个可以返回执行脚本后的返回值</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/24/iOS9之后 HTTP访问不了/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bonway">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bonway">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/24/iOS9之后 HTTP访问不了/" itemprop="url">iOS9之后 HTTP访问不了</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-24T14:23:26+08:00">
                2015-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!------->
<p>今天升级 <i style="font-family:arial;color:#ff2837;font-size:15px;background-color:#ffe9ce">Xcode 7.0 bata</i> 发现网络访问失败。</p>
<p>输出错误信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.</div></pre></td></tr></table></figure>
<p>通过翻墙 Google 后，iOS9引入了新特性<code>App Transport Security (ATS)</code>。详情：App Transport Security (ATS)</p>
<p>新特性要求App内访问的网络必须使用HTTPS协议。<br>但是现在公司的项目使用的是HTTP协议，使用私有加密方式保证数据安全。现在也不能马上改成HTTPS协议传输。</p>
<h3 id="最终找到以下解决办法"><a href="#最终找到以下解决办法" class="headerlink" title="最终找到以下解决办法"></a>最终找到以下解决办法</h3><ol>
<li>在<code>Info.plist</code>中添加 <code>NSAppTransportSecurity</code> 类型 <code>Dictionary</code>。</li>
<li>在<code>NSAppTransportSecurity</code>下添加 <code>NSAllowsArbitraryLoads</code> 类型 <code>Boolean</code>,值设为<code>YES</code>。</li>
</ol>
<h3 id="如下图显示"><a href="#如下图显示" class="headerlink" title="如下图显示"></a>如下图显示</h3><p><img src="/img/iOS9之后HTTP访问不了/iOS9之后HTTP访问不了_001.jpg" alt="“iOS9之后 HTTP访问不了_001”"></p>
<p>如果你有任何问题请随时联系我:<br><img src="/img/googleEmail.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/08/25/IOS的APP结构、生命周期、main/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bonway">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bonway">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/08/25/IOS的APP结构、生命周期、main/" itemprop="url">IOS的APP结构、生命周期、main</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-08-25T19:53:05+08:00">
                2014-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>从<i style="font-family:arial;color:#88CCBE;font-size:15px"> Android </i>转型从事<i style="font-family:arial;color:#ff2837;font-size:15px"> iOS </i>研发，发现很多东西都万变不离其中，这里根据的是自己的了解，做一个笔记（好记性不如烂笔头）。<br>（本文章基于的文档是IOS 8.3）</p>
<h3 id="1、IOS的APP结构："><a href="#1、IOS的APP结构：" class="headerlink" title="1、IOS的APP结构："></a>1、IOS的APP结构：</h3><p>iOS应用程序使用模型-视图-控制器架构（Model-View-Controller）。</p>
<p>这种模式将应用程序的数据和业务逻辑与数据的视觉呈现分离。</p>
<p>这种架构是至关重要的创建应用程序，可以运行在不同的屏幕大小的不同设备。</p>
<p><img src="/img/iOSAPPMain/iOSAPPMain1.jpg" alt=""></p>
<p>其实，苹果的document对其解释的非常清楚，并对相应的Object做了非常详细的解说。（以下是自己的理解，不是十分的完善，具体的请看苹果的官方文档）</p>
<ul>
<li>UIApplication object对象管理事件循环和其它高级应用程序的行为。它还报告了关键的应用程序转换和一些特殊的事件（如传入的推送通知）。</li>
<li>App delegate objectApp deletegate是代码的核心。这个对象在UIApplication对象串联处理应用程序中初始化，该对象也是唯一一个在每个应用程序中存在的，所以它经常被用来建立应用程序的初始数据结构。 </li>
<li>Documents and data model objects数据模型对象存储您的应用程序的内容，是特定于您的应用程序。</li>
<li>View controller objects View Controller 控制器管理您的应用程序的内容在屏幕上演示。</li>
<li>UIWindow object一个UIWindow对象在屏幕上呈现一个或多个视图。Windows使用UIApplication对象事件传送给你的视图和视图控制器。</li>
<li>View objects,control objects, and layer objects 视图和控件提供的可视化表示应用程序的内容。</li>
</ul>
<h3 id="2、在主循环中处理事件："><a href="#2、在主循环中处理事件：" class="headerlink" title="2、在主循环中处理事件："></a>2、在主循环中处理事件：</h3><p><img src="/img/iOSAPPMain/iOSAPPMain2.jpg" alt=""></p>
<p>看图应该就可以了解，就不做多解释了。</p>
<p>###3、IOS应用程序的执行状态：</p>
<p><img src="/img/iOSAPPMain/iOSAPPMain3.jpg" alt=""></p>
<p><code>Not running（未运行）</code>程序没启动。</p>
<p><code>Inactive（未激活）</code>程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态。</p>
<p><code>Active（激活）</code>程序在前台运行而且接收到了事件。这也是前台的一个正常的模式。</p>
<p><code>Backgroud（后台）</code>程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态。</p>
<p><code>Suspended（挂起）</code>程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</p>
<p><img src="/img/iOSAPPMain/iOSAPPMain8.jpg" alt=""></p>
<pre><code>//这个方法是你的应用程序在启动时执行代码的第一次机会。
-(BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions{
    NSLog(@&quot;%s&quot;,__func__);
    return YES;
}

//此方法允许您在应用程序显示给用户之前执行任何最终的初始化。
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    NSLog(@&quot;%s&quot;,__func__);
       return YES;
}

//让你的应用程序知道它即将成为前台应用程序。
- (void)applicationDidBecomeActive:(UIApplication *)application {
    NSLog(@&quot;%s&quot;,__func__);
}

//让你知道你的程序是远离的前台。用这种方法把你的应用程序放在静态的状态。
- (void)applicationWillResignActive:(UIApplication *)application {
    NSLog(@&quot;%s&quot;,__func__);
}

//让你知道你的应用程序正在后台运行，可以随时暂停。
- (void)applicationDidEnterBackground:(UIApplication *)application {
    NSLog(@&quot;%s&quot;,__func__);
}

//让你知道你的应用程序是从后台进入前台，但它是不活跃。
- (void)applicationWillEnterForeground:(UIApplication *)application {
    NSLog(@&quot;%s&quot;,__func__);
}

//让你知道你的应用程序正在被终止。如果你的应用程序被暂停，该方法不会被调用。
- (void)applicationWillTerminate:(UIApplication *)application {
       NSLog(@&quot;%s&quot;,__func__);
}
</code></pre><p>对官方文档中的方法对应的方法中键入NSLog打印。</p>
<p>现在启动程序看看执行的顺序：</p>
<p>启动程序</p>
<p>2014-08-25 20:58:18.350 AppLifeCycle[3055:360067] -<code>[AppDelegate application:willFinishLaunchingWithOptions:]</code></p>
<p>2014-08-25 20:58:18.351 AppLifeCycle[3055:360067] -<code>[AppDelegate application:didFinishLaunchingWithOptions:]</code></p>
<p>2014-08-25 20:58:18.412 AppLifeCycle[3055:360067] -<code>[AppDelegate applicationDidBecomeActive:]</code><br>单击home键（退回到手机桌面）</p>
<p>2014-08-25 20:58:20.395 AppLifeCycle[3055:360067] -<code>[AppDelegate applicationWillResignActive:]</code></p>
<p>2014-08-25 20:58:20.938 AppLifeCycle[3055:360067] -<code>[AppDelegate applicationDidEnterBackground:]</code><br>单击home键后，再打开程序（接上一步，从手机桌面进入程序，）</p>
<p>2014-08-25 20:58:22.421 AppLifeCycle[3055:360067] -<code>[AppDelegate applicationWillEnterForeground:]</code></p>
<p>2014-08-25 20:58:22.935 AppLifeCycle[3055:360067] -<code>[AppDelegate applicationDidBecomeActive:]</code><br>双击home键后，再打开程序（在程序中，直接双击home键，在进入程序）</p>
<p>2014-08-25 20:58:25.385 AppLifeCycle[3055:360067] -<code>[AppDelegate applicationWillResignActive:]</code></p>
<p>2014-08-25 20:58:27.496 AppLifeCycle[3055:360067] -<code>[AppDelegate applicationDidBecomeActive:]</code></p>
<h3 id="4、加载程序："><a href="#4、加载程序：" class="headerlink" title="4、加载程序："></a>4、加载程序：</h3><p>对于大多数从培训班里出来或者是自学IOS的可能连程序是如何加载到前台的也不知道，已经曾经在C或者Java中接触到的main函数，在IOS中时怎么使用的更不清楚，只知道code，却对这些并不了解。</p>
<pre><code>//  main.m
//  AppLifeCycle
//
//  Created by ma c on 14/08/25.
//  Copyright (c) 2014年 Bonway. All rights reserved.

#import &lt;UIKit/UIKit.h&gt;
#import &quot;AppDelegate.h&quot;

int main(int argc, char * argv[]) {
       @autoreleasepool {
       return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
</code></pre><p>main函数中的 int argc，char *argv[ ],大家应该在控制台的oc代码中也见过，这里就不说了。</p>
<p>@autoreleasepool 自动释放池，对于每一个Runloop， 系统会隐式创建一个Autorelease pool（自然会有多个Autorelease pool），这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</p>
<p>UIApplicationMain中的四个参数：<br>argc和 argc[ ]是从前面的参数带过来的，就不多说了。</p>
<p>第三个参数：其底层是principalClassName：这个参数标识了应用程序的类的名称。是负责运行应用程序的类。</p>
<p>第四个参数：其底层是delegateClassName：看名字就知道，这个是应用程序类的代理类 。应用程序的代理负责管理系统和你的代码之间的高层次的互动</p>
<p><code>当我们创建一个新的IOS project时，系统默认的会给我们创建出一个Main.storyboard，加载应用程序的主用户界面文件就是UIapplicationMain做的事，应用程序storyboard.main的文件名应该在应用程序的Info.plist文件中的Main storyboard file base name键值中设定。</code></p>
<p>通常情况下，Xcode会在你创建项目时创建相应键的值，但可以根据需要进行更改。 </p>
<p>如果主要.main文件存在，就会在.main文件对象里寻找Application对象和连接它的delegate。此函数会根据principalClassName创建UIApplication对象，然后根据delegateClassName创建一个delegate对象，并将UIApplication对象中的delegate属性设置为delegate对象。 </p>
<p>当你不想使用系统自带的storyboard.main时，可以在图中，将main删除掉(删除一处，另一处相对应的将自动删除)。</p>
<ol>
<li><p>info.plist<br><img src="/img/iOSAPPMain/iOSAPPMain4.jpg" alt=""></p>
</li>
<li><p><img src="/img/iOSAPPMain/iOSAPPMain5.jpg" alt=""><br>(Launching an app into the foreground)加载应用程序到前台<br><img src="/img/iOSAPPMain/iOSAPPMain6.jpg" alt=""><br>(Launching an app into the background)加载应用程序到后台<br><img src="/img/iOSAPPMain/iOSAPPMain7.jpg" alt=""></p>
</li>
</ol>
<p>参考：<a href="https://developer.apple.com/library/content/navigation/" target="_blank" rel="external">苹果官方文档</a></p>
<p>如果你有任何问题请随时联系我:<br><img src="/img/googleEmail.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/06/26/UIWebView与WKWebView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bonway">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bonway">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/06/26/UIWebView与WKWebView/" itemprop="url">UIWebView与WKWebView(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-26T14:23:26+08:00">
                2014-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>UIWebView</strong></p>
<p>UIWebView是苹果继承于UIView封装的一个加载web内容的类,它可以加载任何远端的web数据展示在你的页面上，你可以像浏览器一样前进后退刷新等操作。不过苹果在iOS8以后推出了WKWebView来加载Web，下面再详细介绍下WKWebView。</p>
<p>UIWebView属于UIKit，封装了WebKit.framework的WebView.</p>
<p>WebView组合管理了WebCore.framework的Page,并提供了各种Clients.</p>
<p>Page管理了Main Frame，Main Frame管理了sub Frame（FrameTree)(关于详细的UIWebView介绍转自<a href="http://blog.csdn.net/hursing" target="_blank" rel="external">这里</a>)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-9606be8659abf5f6..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1470807807124957.png" title="1470807807124957.png"></p>
<p>WebView继承自WAKView,WAKView类似于NSView，可以做较少的改动使得Mac和iOS共用一套。由UIWebDocumentView对WebView进行操作并接收回调事件，当数据发生变化的时候，就会通知UIWebTiledView重新绘制。</p>
<p>UIWebTiledView和WAKWindow这两个类主要负责页面的绘制，包括布局绘图排版，交互等,WAKWindow还会做一些用户操作事件的分派。</p>
<p><strong>UIWebBrowserView主要负责：</strong></p>
<ul>
<li><p>form的自动填充</p>
</li>
<li><p>fixed元素的位置调整</p>
</li>
<li><p>JavaScript的手势识别</p>
</li>
<li><p>键盘弹出时的视图滚动处理，防止遮挡</p>
</li>
<li><p>提供接口让UIWebView获取信息</p>
</li>
<li><p>为显示PDF时添加页号标签</p>
</li>
</ul>
<p>通过反编译可以获得UIWebViewInternal的具体成员变量</p>
<p><code>@interface UIWebViewInternal : NSObject</code></p>
<p><code>{</code></p>
<p><code>UIScrollView *scroller;</code></p>
<p><code>UIWebBrowserView *browserView;</code></p>
<p><code>UICheckeredPatternView *checkeredPatternView;</code></p>
<p><code>iddelegate;</code></p>
<p><code>unsigned int scalesPageToFit;</code></p>
<p><code>unsigned int isLoading;</code></p>
<p><code>unsigned int hasOverriddenOrientationChangeEventHandling;</code></p>
<p><code>unsigned int drawsCheckeredPattern;</code></p>
<p><code>unsigned int webSelectionEnabled;</code></p>
<p><code>unsigned int drawInWebThread;</code></p>
<p><code>unsigned int inRotation;</code></p>
<p><code>NSURLRequest *request;</code></p>
<p><code>int clickedAlertButtonIndex;</code></p>
<p><code>UIWebViewWebViewDelegate *webViewDelegate;</code></p>
<p><code>UIWebPDFViewHandler *pdfHandler;</code></p>
<p><code>}</code></p>
<p><code>@end</code></p>
<p>由此可以看出UIWebViewInternal是接收WebView的事件的载体通过自身把WebView的事件传递给UIWebView.</p>
<p><strong>WKWebView</strong></p>
<p>通过上面的了解，苹果终于在8.0之后开放了WKWebView应用于iOS和OSX中，它取代了UIWebView和WebView，在两个平台上支持同一套API。</p>
<p>它脱离于UIWebView的设计，将原本的设计拆分成14个类，和3个代理协议，虽然是这样但是了解之后其实用法比较简单，依照职责单一的原则，每个协议做的事情根据功能分类。</p>
<p><strong>WKWebView相比于UIWebView</strong></p>
<ul>
<li><p>WKWebView的内存远远没有UIWebView的开销大,而且没有缓存</p>
</li>
<li><p>拥有高达60FPS滚动刷新率及内置手势</p>
</li>
<li><p>支持了更多的HTML5特性</p>
</li>
<li><p>高效的app和web信息交换通道</p>
</li>
<li><p>允许JavaScript的Nitro库加载并使用,UIWebView中限制了</p>
</li>
<li><p>WKWebView目前缺少关于页码相关的API</p>
</li>
<li><p>提供加载网页进度的属性</p>
</li>
</ul>
<p><strong>WKWebView的协议</strong></p>
<p><strong>WKScriptMessageHandler协议</strong></p>
<p><code>window.webkit.messageHandlers.{NAME}.postMessage()</code></p>
<p>可以把JavaScript对象通过该API自动转换成Objective-C或Swift 对象,Name可以通过addScriptMessageHandler: name:来设置<br><code>- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{</code></p>
<p><code>}</code></p>
<p>作为唯一响应JavaScript的协议方法，目的是为了与其它的进行分离，在该协议中响应之前注入的MessageHandlers.</p>
<p>可以根据WKScriptMessage知道Js的名称和参数，来区分不同的响应事件</p>
<p><strong>WKNavigationDelegate协议</strong></p>
<p>提供了追踪主窗口网页加载过程和判断主窗口和子窗口是否进行页面加载新页面的相关方法,相当于UIWebView中webViewDidFinishLoad和webViewDidStartLoad方法,除了有开始加载、加载成功、加载失败的API外，还具有额外的三个代理方法：<br><code>- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation;</code></p>
<p><code>- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;</code></p>
<p><code>- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler;</code></p>
<p>第一个是服务器redirect时调用</p>
<p>第二个API是根据客户端受到的服务器响应头以及response相关信息来决定是否可以跳转</p>
<p>第三个API是根据WebView对于即将跳转的HTTP请求头信息和相关信息来决定是否跳转</p>
<p><strong>WKUIDelegate协议</strong></p>
<p>提供用原生控件显示网页的方法回调,例如Alert提示可以自定义用原生的控件来实现</p>
<p><code>- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler {</code></p>
<p><code>UIAlertController *alert = [UIAlertController alertControllerWithTitle:nil message:message preferredStyle:UIAlertControllerStyleAlert];</code></p>
<p><code>[alert addAction:[UIAlertAction actionWithTitle:@``&quot;确定&quot;</code> <code>style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {</code></p>
<p><code>completionHandler();</code></p>
<p><code>}]];</code></p>
<p><code>[self presentViewController:alert animated:YES completion:NULL];</code></p>
<p><code>}</code></p>
<p><strong>总结</strong></p>
<p>WKWebView相较于UIWebView在整体上有较大的提升，满足OS上面使用同一套控件的功能，同时对整个内存的开销以及滚动刷新率和JS交互做了优化的处理。依据职责单一的原则，拆分成了三个协议去实现WebView的响应，解耦了JS交互和加载进度的响应处理。WKWebView没有做缓存处理,所以对网页需要缓存的加载性能要求没那么高的还是可以考虑UIWebView.</p>
<p>结合以上这些，最近封装一个基础的WebView控件<a href="https://github.com/chausson/CHWebView" target="_blank" rel="external">CHWebView</a>，目前并没有做成一个通用控件,反而是封装带有UIWebView和WKWebView的基类，以后有时间的话把WebView这一层分离</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-efa5b0b927fd7f9e..gif?imageMogr2/auto-orient/strip" alt="WebView.gif" title="1470807846307240.gif"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/06/25/UIWebView与WKWebView-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bonway">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bonway">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/06/25/UIWebView与WKWebView-一/" itemprop="url">UIWebView与WKWebView(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-25T14:23:26+08:00">
                2014-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><i style="font-family:arial;color:#88CCBE;font-size:15px">UIWebView</i> 自 <code>iOS2.0</code> 就有，<i style="font-family:arial;color:#ff2837;font-size:15px">WKWebView</i> 从 <code>iOS8.0</code> 才有，毫无疑问<i style="font-family:arial;color:#ff2837;font-size:15px">WKWebView</i>将逐步取代笨重的<i style="font-family:arial;color:#88CCBE;font-size:15px">UIWebView</i>。通过简单的测试即可发现<i style="font-family:arial;color:#88CCBE;font-size:15px">UIWebView</i>占用过多内存以及加载时间过长，且内存峰值更是夸张。<i style="font-family:arial;color:#ff2837;font-size:15px">WKWebView</i>网页加载速度也有提升，但是并不像内存那样提升那么多（之后将会用图片进行具体的认证）。下面列举一些其它的优势：</p>
<ol>
<li>更多的支持HTML5的特性。</li>
<li>官方宣称的高达60fps的滚动刷新率以及内置手势。</li>
<li>Safari相同的JavaScript引擎</li>
<li>将UIWebViewDelegate与UIWebView拆分成了14类与3个协议(官方文档说明)<a href="https://developer.apple.com/reference/webkit" target="_blank" rel="external">https://developer.apple.com/reference/webkit</a></li>
</ol>
<h3 id="UIWebView的简单使用"><a href="#UIWebView的简单使用" class="headerlink" title="UIWebView的简单使用"></a>UIWebView的简单使用</h3><ul>
<li><p>创建</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　UIWebView *webView = [[UIWebView alloc]initWithFrame:self.view.bounds];</div><div class="line">　NSURLRequest *request = [NSURLRequest requestWithURL:[NSURLURLWithString:@&quot;https://www.baidu.com&quot;]];</div><div class="line">　[webView  loadRequest:request];</div><div class="line">　[self.view addSubview:webView];</div></pre></td></tr></table></figure>
</li>
<li><p>加载函数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　- (void)loadRequest:(NSURLRequest *)request;</div><div class="line">　- (void)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;</div><div class="line">　- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;</div></pre></td></tr></table></figure>
</li>
<li><p>导航函数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">　- (void)reload;// 刷新</div><div class="line">　- (void)stopLoading;// 停止加载</div><div class="line">　- (void)goBack;// 后退函数</div><div class="line">　- (void)goForward;// 前进函数</div><div class="line">　@property (nonatomic, readonly, getter=canGoBack) BOOL canGoBack;// 是否可以后退</div><div class="line">　@property (nonatomic, readonly, getter=canGoForward) BOOL canGoForward;// 是否可以向前</div><div class="line">　@property (nonatomic, readonly, getter=isLoading) BOOL loading;// 是否正在加载</div></pre></td></tr></table></figure>
</li>
<li><p>代理协议：UIWebViewDelegate</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">　// 是否允许加载网页，也可获取js要打开的url，通过截取此url可与js交互</div><div class="line">　- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType；</div><div class="line">　// 开始加载网页</div><div class="line">　- (void)webViewDidStartLoad:(UIWebView *)webView；</div><div class="line">　// 网页加载完成</div><div class="line">　- (void)webViewDidFinishLoad:(UIWebView *)webView；</div><div class="line">　// 网页加载错误</div><div class="line">　- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error；</div></pre></td></tr></table></figure>
</li>
<li><p>与js交互</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSString *javascriptStr = @&quot;...&quot;//你要执行的代码</div><div class="line">// webview执行代码</div><div class="line">[self.webView stringByEvaluatingJavaScriptFromString:javascriptStr];</div><div class="line">// 获取网页的title</div><div class="line">NSString *title = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;]</div></pre></td></tr></table></figure>
</li>
</ul>
<p style="font-family:arial;color:#ff2837;font-size:18px">小结:</p> 

<ol>
<li>UIWebView使用简单，系统自己给你设置可Cookie，从这一点上，比WKWebView方便。当然，有个性的需求除外（如：清空缓存等等，在之后的章节会说到）。</li>
<li>UIWebView的代理方法之后4个，相比WKWebView，结论可想而知。有的时候需要在代理协议（webViewDidFinishLoad），执行相应的js代码，会产生慢半拍的感觉，如果放在（webViewDidStartLoad）中，会没有效果，因为页面还没加载。标题也是一样，出来的比较慢。</li>
</ol>
<h3 id="WKWebView的简单使用"><a href="#WKWebView的简单使用" class="headerlink" title="WKWebView的简单使用"></a>WKWebView的简单使用</h3><ul>
<li><p>创建</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　WKWebView *webView = [[WKWebView alloc]initWithFrame:self.view.bounds];</div><div class="line">　NSURLRequest *request = [NSURLRequest requestWithURL:[NSURLURLWithString:@&quot;https://www.baidu.com&quot;]];</div><div class="line">　[webView  loadRequest:request];</div><div class="line">　[self.view addSubview:webView];</div></pre></td></tr></table></figure>
</li>
</ul>
<p><i style="font-family:arial;color:#ff2837;font-size:15px">注意：</i>需要导入 `#import <webkit webkit.h=""></webkit></p>
<ul>
<li><p>加载函数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　- (void)loadLocalFile;// 模拟器调试加载mac本地文件</div><div class="line">　- (WKNavigation *)loadRequest:(NSURLRequest *)request;</div><div class="line">　- (WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;</div><div class="line">　- (WKNavigation *)loadData:(NSData *)data MIMEType:(NSString *)MIMEType characterEncodingName:(NSString *)characterEncodingName baseURL:(NSURL *)baseURL;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果你有任何问题请随时联系我:<br><img src="/img/googleEmail.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/11/04/iOS枚举的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bonway">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bonway">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2013/11/04/iOS枚举的使用/" itemprop="url">iOS枚举的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-11-04T13:08:18+08:00">
                2013-11-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>枚举类型: <a style="font-family:arial;color:#ff2837;font-size:15px">enum,NS_ENUM,NS_OPTIONS</a> 枚举值一般是4个字节的int值，在64位系统上是8个字节。</p>
<p>在iOS6和Mac OS 10.8以后Apple引入了两个宏来重新定义这两个枚举类型，实际上是将enum定义和typedef合二为一，并且采用不同的宏来从代码角度来区分。</p>
<p>NS_ENUM一般用来普通的相关枚举的操作。NS_OPTIONS一般用来定义位移相关操作的枚举值，我们可以参考UIKit.Framework的头文件，可以看到大量的枚举定义。</p>
<p>这两个宏的定义在Foundation.framework的NSObjCRuntime.h中：</p>
<pre><code>#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) ||     __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))  
#define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type  
#if (__cplusplus)  
#define NS_OPTIONS(_type, _name) _type _name; enum : _type  
#else  
#define NS_OPTIONS(_type, _name) enum _name : _type _name; enum _name : _type  
#endif  
#else  
#define NS_ENUM(_type, _name) _type _name; enum  
#define NS_OPTIONS(_type, _name) _type _name; enum  
#endif 
</code></pre><h4 id="example："><a href="#example：" class="headerlink" title="example："></a>example：</h4><pre><code>typedef NS_ENUM    (NSInteger, UITableViewCellSeparatorStyle) {
    UITableViewCellSeparatorStyleNone,
    UITableViewCellSeparatorStyleSingleLine,
    UITableViewCellSeparatorStyleSingleLineEtched   // This separator style is only supported for grouped style table views currently
}
typedef NS_OPTIONS (NSUInteger, UITableViewCellStateMask) {
    UITableViewCellStateDefaultMask                     = 0,
    UITableViewCellStateShowingEditControlMask          = 1 &lt;&lt; 0,
    UITableViewCellStateShowingDeleteConfirmationMask   = 1 &lt;&lt; 1
};
</code></pre><p>如果你有任何问题请随时联系我:<br><img src="/img/googleEmail.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/10/20/NSString-字符串截取/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bonway">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bonway">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2013/10/20/NSString-字符串截取/" itemprop="url">NSString 字符串截取</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-10-20T14:23:26+08:00">
                2013-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!--title: NSString 字符串截取 -->
<!------->
<h3 id="1-截取字符串"><a href="#1-截取字符串" class="headerlink" title="1.截取字符串"></a>1.截取字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;ibonway&quot;;</div><div class="line">string = [string substringToIndex:3];//截取掉下标3之前的字符串</div><div class="line">NSLog(@&quot;截取的值为：%@&quot;,string);</div><div class="line">string = [string substringFromIndex:2];//截取掉下标2之后的字符串</div><div class="line">NSLog(@&quot;截取的值为：%@&quot;,string);</div></pre></td></tr></table></figure>
<p>//结果：截取的值为：ibo<br>//结果：截取的值为：onway</p>
<h3 id="2-匹配字符串"><a href="#2-匹配字符串" class="headerlink" title="2.匹配字符串"></a>2.匹配字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSString*string = @&quot;ibonway&quot;;</div><div class="line">NSRange range = [string rangeOfString:@&quot;w&quot;];//匹配得到的下标</div><div class="line">NSLog(@&quot;rang:%@&quot;,NSStringFromRange(range));</div><div class="line">string = [string substringWithRange:range];//截取范围类的字符串</div><div class="line">NSLog(@&quot;截取的值为：%@&quot;,string);</div></pre></td></tr></table></figure>
<p>//结果：rang:{4, 1}<br>//结果：截取的值为：w</p>
<h3 id="3-分隔字符串"><a href="#3-分隔字符串" class="headerlink" title="3.分隔字符串"></a>3.分隔字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;ibonway&quot;;</div><div class="line">NSArray *array = [string componentsSeparatedByString:@&quot;w&quot;]; //从字符A中分隔成2个元素的数组</div><div class="line">NSLog(@&quot;array:%@&quot;,array);</div></pre></td></tr></table></figure>
<p>//结果：array:(ibon,ay)</p>
<p>如果你有任何问题请随时联系我:<br><img src="/img/googleEmail.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Bonway" />
          <p class="site-author-name" itemprop="name">Bonway</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bonway</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
