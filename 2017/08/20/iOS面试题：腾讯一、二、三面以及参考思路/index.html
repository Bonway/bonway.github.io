<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/source/images/favicon.ico?v=5.1.2" />






<meta name="description" content="使用了第三方库, 有看他们是怎么实现的吗？

例：SD、YY、AFN、MJ等！
.SD为例：
1.入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。
2.进入 SDWebImageManagerdownloadWithURL:delegat">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS面试题：腾讯一、二、三面以及参考思路">
<meta property="og:url" content="http://yoursite.com/2017/08/20/iOS面试题：腾讯一、二、三面以及参考思路/index.html">
<meta property="og:site_name" content="Bonway">
<meta property="og:description" content="使用了第三方库, 有看他们是怎么实现的吗？

例：SD、YY、AFN、MJ等！
.SD为例：
1.入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。
2.进入 SDWebImageManagerdownloadWithURL:delegat">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10991770-235e741680a0d4c4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10991770-9e516f77f5f2cfef..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10991770-cf52a7c313d0e375..gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10991770-c2e90bcd7737a336..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10991770-5e3b029634165a15..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10991770-f1936f7a6fad0410..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10991770-d5c4a5a4df2f2d09..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10991770-c3cec610e905b9da..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10991770-76e54938dd128070..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10991770-3ac4706a654b84c0..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-03-08T10:16:05.372Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS面试题：腾讯一、二、三面以及参考思路">
<meta name="twitter:description" content="使用了第三方库, 有看他们是怎么实现的吗？

例：SD、YY、AFN、MJ等！
.SD为例：
1.入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。
2.进入 SDWebImageManagerdownloadWithURL:delegat">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/10991770-235e741680a0d4c4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/20/iOS面试题：腾讯一、二、三面以及参考思路/"/>





  <title>iOS面试题：腾讯一、二、三面以及参考思路 | Bonway</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bonway</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/iOS面试题：腾讯一、二、三面以及参考思路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bonway">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bonway">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS面试题：腾讯一、二、三面以及参考思路</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T14:23:26+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ol>
<li><strong>使用了第三方库, 有看他们是怎么实现的吗？</strong></li>
</ol>
<p>例：SD、YY、AFN、MJ等！</p>
<p><strong><1>.SD为例：</1></strong></p>
<p><code>1.入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。</code></p>
<p><code>2.进入 SDWebImageManagerdownloadWithURL:delegate:options:userInfo:交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.</code></p>
<p><code>3.先从内存图片缓存查找是否有图片如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。</code></p>
<p><code>4.SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。</code></p>
<p><code>5.如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。</code></p>
<p><code>6.根据 URLKey 在硬盘缓存目录下尝试读取图片文件。</code></p>
<p><code>这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。</code></p>
<p><code>7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。</code></p>
<p><code>8.如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。</code></p>
<p><code>9.共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。</code></p>
<p><code>10.图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。</code></p>
<p><code>11.connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。</code></p>
<p><code>12.connectionDidFinishLoading: 数据下载完成后交 SDWebImageDecoder 做图片解码处理。</code></p>
<p><code>13.图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。</code></p>
<p><code>14.在主线程 notifyDelegateOnMainThreadWithInfo:宣告解码完成，</code></p>
<p><code>imageDecoder:didFinishDecodingImage:userInfo回调给 SDWebImageDownloader。</code></p>
<p><code>15.imageDownloader:didFinishWithImage:回调给 SDWebImageManager 告知图片下载完成。</code></p>
<p><code>16.通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。</code></p>
<p><code>17.将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。</code></p>
<p><code>18.SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存</code></p>
<p><code>应用结束的时候清理过期图片。</code></p>
<p><code>19.SDWI 也提供了 UIButton+WebCache 和MKAnnotationView+WebCache，方便使用。</code></p>
<p><code>20.SDWebImagePrefetcher 可以预先下载图片，方便后续使用。</code></p>
<p><strong>2.强连通分量了解嘛？</strong></p>
<p><strong>概念：</strong></p>
<p>有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。</p>
<p><strong>定义：</strong></p>
<p>有向图强连通分量：</p>
<p>在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点强连通（strongly connected）。</p>
<p>如果有向图G的每两个顶点都强连通，则称G是一个强连通图。</p>
<p>非强连通图有向图的极大强连通子图，成为强连通分量（strongly connected components）。</p>
<p>下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达，{5}，{6}也分别是两个强连通分量。<br><img src="http://upload-images.jianshu.io/upload_images/10991770-235e741680a0d4c4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.jpg"></p>
<p>直接根据定义，用双向遍历取交际的方法求强连通分量，时间复杂度为O（N^2+M）。更好的方法是Kosaraju算法或者Tarjan算法两者的时间复杂度都是O（N+M）。本文介绍的是Tarjan算法。</p>
<p><strong>算法原理：（Tarjan）</strong></p>
<p>need-to-insert-img</p>
<p>Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一颗子树。</p>
<p>搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以盘对栈顶到栈中的节点是否为一个强连通分量。</p>
<p>定义DFN（u）为节点u搜索的次序编号（时间戳）。Low（u）为u或者u的子树能够追溯到的最早的栈中的节点的次序号。</p>
<p>由定义可以得出：</p>
<p>Low（u）= Min { DFN（u）， Low（v）} （（u，v）为树枝边，u为v的父节点DFN（v），（u，v）为指向栈中节点的后向边（非横叉边））</p>
<p>当DFN（u）=Low（u）时，以u为根的搜索子树上所有节点是一个强连通分量。</p>
<p><strong>3.遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？</strong></p>
<p><strong>可能造成tableView卡顿的原因有：</strong></p>
<p><strong>1.最常用的就是cell的重用， 注册重用标识符</strong></p>
<p>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell</p>
<p>如果有很多数据的时候，就会堆积很多cell。</p>
<p>如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell</p>
<p><strong>2.避免cell的重新布局</strong></p>
<p>cell的布局填充等操作 比较耗时，一般创建时就布局好</p>
<p>如可以将cell单独放到一个自定义类，初始化时就布局好</p>
<p><strong>3.提前计算并缓存cell的属性及内容</strong></p>
<p>当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度</p>
<p>而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</p>
<p><strong>4.减少cell中控件的数量</strong></p>
<p>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，</p>
<p>不适用的可以先隐藏</p>
<p><strong>5.不要使用ClearColor，无背景色，透明度也不要设置为0</strong></p>
<p>渲染耗时比较长</p>
<p><strong>6.使用局部更新</strong></p>
<p>如果只是更新某组的话，使用reloadSection进行局部更</p>
<p><strong>7.加载网络数据，下载图片，使用异步加载，并缓存</strong></p>
<p><strong>8.少使用addView 给cell动态添加view</strong></p>
<p><strong>9.按需加载cell，cell滚动很快时，只加载范围内的cell</strong></p>
<p><strong>10.不要实现无用的代理方法，tableView只遵守两个协议</strong></p>
<p><strong>11.缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可</strong></p>
<p><strong>12.不要做多余的绘制工作。</strong>在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。</p>
<p><strong>13.预渲染图像。</strong>当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕；</p>
<p><strong>14.使用正确的数据结构来存储数据。</strong></p>
<p><strong>4.M、V、C相互通讯规则你知道的有哪些？</strong></p>
<p><strong>MVC 是一种设计思想，一种框架模式，是一种把应用中所有类组织起来的策略，它把你的程序分为三块，分别是：</strong></p>
<p><strong>M（Model</strong>）：实际上考虑的是“什么”问题，你的程序本质上是什么，独立于 UI 工作。是程序中用于处理应用程序逻辑的部分，通常负责存取数据。</p>
<p>C（Controller）：控制你 Model 如何呈现在屏幕上，当它需要数据的时候就告诉 Model，你帮我获取某某数据；当它需要 UI 展示和更新的时候就告诉 View，你帮我生成一个 UI 显示某某数据，是 Model 和 View 沟通的桥梁。</p>
<p><strong>V（View）</strong>：Controller 的手下，是 Controller 要使用的类，用于构建视图，通常是根据 Model 来创建视图的。</p>
<p><strong>要了解 MVC 如何工作，首先需要了解这三个模块间如何通信。</strong></p>
<p>MVC通信规则</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-9e516f77f5f2cfef..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.jpg" title="1511752329535960.jpg"></p>
<p><strong>Controller to Model</strong></p>
<p>可以直接单向通信。Controller 需要将 Model 呈现给用户，因此需要知道模型的一切，还需要有同 Model 完全通信的能力，并且能任意使用 Model 的公共 API。</p>
<p><strong>Controller to View</strong></p>
<p>可以直接单向通信。Controller 通过 View 来布局用户界面。</p>
<p><strong>Model to View</strong></p>
<p>永远不要直接通信。Model 是独立于 UI 的，并不需要和 View 直接通信，View 通过 Controller 获取 Model 数据</p>
<p><strong>View to Controller</strong></p>
<p>View 不能对 Controller 知道的太多，因此要通过间接的方式通信。</p>
<p>Target</p>
<p>action。首先 Controller 会给自己留一个 target，再把配套的 action 交给 View 作为联系方式。那么 View</p>
<p>接收到某些变化时，View 就会发送 action 给 target 从而达到通知的目的。这里 View 只需要发送</p>
<p>action，并不需要知道 Controller 如何去执行方法。</p>
<p>代理。有时候 View 没有足够的逻辑去判断用户操作是否符合规范，他会把判断这些问题的权力委托给其他对象，他只需获得答案就行了，并不会管是谁给的答案。</p>
<p>DataSoure。View 没有拥有他们所显示数据的权力，View 只能向 Controller 请求数据进行显示，Controller 则获取 Model 的数据整理排版后提供给 View。</p>
<p>Model 访问 Controller</p>
<p>同样的 Model 是独立于 UI 存在的，因此无法直接与 Controller 通信，但是当 Model 本身信息发生了改变的时候，会通过下面的方式进行间接通信。</p>
<p><strong>Notification &amp; KVO一种类似电台的方法，Model 信息改变时会广播消息给感兴趣的人 ，只要 Controller 接收到了这个广播的时候就会主动联系 Model，获取新的数据并提供给 View。</strong></p>
<p>从上面的简单介绍中我们来简单概括一下 MVC 模式的优点。</p>
<p>1.低耦合性</p>
<p>2.有利于开发分工</p>
<p>3.有利于组件重用</p>
<p>4.可维护性</p>
<p><strong>5.NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?</strong></p>
<p><strong>1.不准</strong></p>
<p><strong>2.不准的原因如下：</strong></p>
<p>1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。</p>
<p>2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。</p>
<p>当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。</p>
<p>PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。</p>
<p><strong>方法一：</strong></p>
<p>1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。</p>
<p>self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];</p>
<p>[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</p>
<p>2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；<br><code>- (void)timerMethod2 {</code><br><code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];</code><br><code>[thread start];</code><br><code>}</code></p>
<p><code>- (void)newThread</code></p>
<p><code>{</code></p>
<p><code>@autoreleasepool</code></p>
<p>  <code>{</code><br><code>[NSTimer scheduledTimerWithTimeInterval:``1.0</code> <code>target:self selector:@selector(showTime) userInfo:nil repeats:YES];</code><br><code>[[NSRunLoop currentRunLoop] run];</code><br><code>}</code></p>
<p><code>}</code><br>总结：</p>
<p>一开始的时候系统就为我们将主线程的main runloop隐式的启动了。<br>在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop</p>
<p><strong>方法二：</strong></p>
<p><strong>使用示例</strong></p>
<p>使用mach内核级的函数可以使用mach_absolute_time()获取到CPU的tickcount的计数值，可以通过”mach_timebase_info”函数获取到纳秒级的精确度 。然后使用mach_wait_until(uint64_t deadline)函数，直到指定的时间之后，就可以执行指定任务了。</p>
<p>关于数据结构mach_timebase_info的定义如下：</p>
<p><code>struct mach_timebase_info {uint32_t numer;uint32_t denom;};</code></p>
<p><code>#include</code></p>
<p><code>#include</code></p>
<p><code>static</code> <code>const</code> <code>uint64_t NANOS_PER_USEC = 1000ULL;</code></p>
<p><code>static</code> <code>const</code> <code>uint64_t NANOS_PER_MILLISEC = 1000ULL * NANOS_PER_USEC;</code></p>
<p><code>static</code> <code>const</code> <code>uint64_t NANOS_PER_SEC = 1000ULL * NANOS_PER_MILLISEC;</code></p>
<p><code>static</code> <code>mach_timebase_info_data_t timebase_info;</code></p>
<p><code>static</code> <code>uint64_t nanos_to_abs(uint64_t nanos) {</code></p>
<p><code>return</code> <code>nanos * timebase_info.denom / timebase_info.numer;</code></p>
<p><code>}</code></p>
<p><code>void</code> <code>example_mach_wait_until(``int</code> <code>seconds)</code></p>
<p><code>{</code></p>
<p><code>mach_timebase_info(&amp;timebase_info);</code></p>
<p><code>uint64_t time_to_wait = nanos_to_abs(seconds * NANOS_PER_SEC);</code></p>
<p><code>uint64_t now = mach_absolute_time();</code></p>
<p><code>mach_wait_until(now + time_to_wait);</code></p>
<p><code>}</code></p>
<p> |</p>
<p><strong>方法三：直接使用GCD替代！</strong></p>
<p><strong><img src="http://upload-images.jianshu.io/upload_images/10991770-cf52a7c313d0e375..gif?imageMogr2/auto-orient/strip" alt="2.gif" title="1511752533900159.gif"></strong> </p>
<p><strong>iOS面试题：腾讯二面以及参考思路：</strong></p>
<ol>
<li><strong>编译过程做了哪些事情？</strong></li>
</ol>
<p>1.C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在CPU上执行，所以执行效率较高。</p>
<p>iOS开发目前的常用语言是：Objective和Swift。二者都是编译语言，换句话说都是需要编译才能执行的。二者的编译都是依赖于Clang + LLVM. OC和Swift因为原理上大同小异，知道一个即可！</p>
<p><strong>iOS编译</strong></p>
<p>不管是OC还是Swift，都是采用Clang作为编译器前端，LLVM(Low level vritual machine)作为编译器后端。所以简单的编译过程如图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-c2e90bcd7737a336..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.jpg" title="1511753444245759.jpg"></p>
<p><strong>编译器前端</strong></p>
<p>编译器前端的任务是进行：语法分析，语义分析，生成中间代码(intermediate representation )。在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-5e3b029634165a15..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.jpg" title="1511753469995468.jpg"></p>
<p><strong>编译器后端</strong></p>
<p>编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。iOS的编译过程，后端的处理如下</p>
<p><strong>LVVM优化器会进行BitCode的生成，链接期优化等等</strong></p>
<p><strong><img src="http://upload-images.jianshu.io/upload_images/10991770-f1936f7a6fad0410..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.jpg" title="1511753575393142.jpg"></strong> </p>
<p><strong>LLVM机器码生成器会针对不同的架构，比如arm64等生成不同的机器码。</strong></p>
<p><strong><img src="http://upload-images.jianshu.io/upload_images/10991770-d5c4a5a4df2f2d09..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.jpg" title="1511753730633498.jpg"></strong> </p>
<p><strong>执行一次XCode build的流程</strong></p>
<p>当你在XCode中，选择build的时候（快捷键command+B），会执行如下过程</p>
<p>编译信息写入辅助文件，创建编译后的文件架构(name.app)</p>
<p>处理文件打包信息，例如在debug环境下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10991770-c3cec610e905b9da..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.jpg" title="1511753750653017.jpg"></p>
<p>执行CocoaPod编译前脚本</p>
<p>例如对于使用CocoaPod的工程会执行CheckPods Manifest.lock</p>
<p>编译各个.m文件，使用CompileC和clang命令。</p>
<p><strong>编译各个.m文件，使用CompileC和clang命令。</strong> </p>
<p><code>1.CompileC ClassName.o ClassName.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</code></p>
<p><code>2.export.US-ASCII</code></p>
<p><code>3.export PATH = &quot;...&quot;</code></p>
<p><code>4.clang-x objective-c -arch x86_64 -fmessage-length=0</code> <code>-fobjc-arc...</code></p>
<p><code>-Wno-missing-field-initializers ... -DDEBUG=``1</code> <code>... -isysroot</code></p>
<p><code>iPhoneSimulator10.``1``.sdk -fasm-blocks ... -I 上文提到的文件 -F 所需要的Framework-iquote 所需要的Framework ... -c ClassName.c -o ClassName.o</code></p>
<p><strong>通过这个编译的命令，我们可以看到</strong></p>
<p><strong><img src="http://upload-images.jianshu.io/upload_images/10991770-76e54938dd128070..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.jpg" title="1511753787248683.jpg"></strong> </p>
<p><strong>2.字典大致实现原理；</strong></p>
<p><strong>一：字典原理</strong></p>
<p>NSDictionary（字典）是使用hash表来实现key和value之间的映射和存储的</p>
<p>方法：- (void)setObject:(id)anObject forKey:(id)aKey;</p>
<p>Objective-C中的字典NSDictionary底层其实是一个哈希表</p>
<p><strong>二：哈希原理</strong></p>
<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<p><strong>哈希概念</strong>:哈希表的本质是一个数组，数组中每一个元素称为一个箱子(bin)，箱子中存放的是键值对。</p>
<p><strong>三：哈希存储过程</strong></p>
<p><strong>1.根据 key 计算出它的哈希值 h。</strong></p>
<p><strong>2.假设箱子的个数为 n，那么这个键值对应该放在第 (h % n) 个箱子中。</strong></p>
<p><strong>3.如果该箱子中已经有了键值对，就使用开放寻址法或者拉链法解决冲突。</strong></p>
<p>在使用拉链法解决哈希冲突时，每个箱子其实是一个链表，属于同一个箱子的所有键值对都会排列在链表中。</p>
<p><strong>哈希表还有一个重要的属性</strong>: 负载因子(load factor)，它用来衡量哈希表的空/满程度，一定程度上也可以体现查询的效率，计算公式为:</p>
<p><strong>负载因子 = 总键值对数 / 箱子个数</strong></p>
<p>负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，哈希表将自动扩容。</p>
<p>哈希表在自动扩容时，一般会创建两倍于原来个数的箱子，因此即使 key 的哈希值不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。</p>
<p>哈希表的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。</p>
<p><strong>基于以上总结，细心的朋友可能会发现哈希表的两个问题:</strong></p>
<p><strong>1.如果哈希表中本来箱子就比较多，扩容时需要重新哈希并移动数据，性能影响较大。</strong></p>
<p><strong>2.如果哈希函数设计不合理，哈希表在极端情况下会变成线性表，性能极低。</strong></p>
<p><strong>3.block和函数指针的理解；</strong></p>
<p><strong>相似点：</strong></p>
<p>函数指针和Block都可以实现回调的操作，声明上也很相似，实现上都可以看成是一个代码片段。</p>
<p>函数指针类型和Block类型都可以作为变量和函数参数的类型。（typedef定义别名之后，这个别名就是一个类型）</p>
<p><strong>不同点：</strong></p>
<p>函数指针只能指向预先定义好的函数代码块（可以是其他文件里面定义，通过函数参数动态传入的），函数地址是在编译链接时就已经确定好的。</p>
<p>Block本质是Objective-C对象，是NSObject的子类，可以接收消息。</p>
<p>函数里面只能访问全局变量，而Block代码块不光能访问全局变量，还拥有当前栈内存和堆内存变量的可读性（当然通过__block访问指示符修饰的局部变量还可以在block代码块里面进行修改）。</p>
<p>从内存的角度看，函数指针只不过是指向代码区的一段可执行代码，而block实际上是程序运行过程中在栈内存动态创建的对象，可以向其发送copy消息将block对象拷贝到堆内存，以延长其生命周期。</p>
<p><strong>4.一般开始做一个项目，你的架构是如何思考的？</strong></p>
<p><a href="https://link.jianshu.com/?t=https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="external">参考文章一</a></p>
<p><a href="https://link.jianshu.com/?t=https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="external">参考文章二</a></p>
<p><strong>5.你了解的UIKit结构？</strong></p>
<p><strong><img src="http://upload-images.jianshu.io/upload_images/10991770-3ac4706a654b84c0..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.jpg" title="1511753924688843.jpg"></strong> </p>
<p><strong>这题应该是在你回答的基础之上，进行二次提问，主要还是看你的基础！</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/08/iOS-WKWebView适配/" rel="next" title="iOS WKWebView适配">
                <i class="fa fa-chevron-left"></i> iOS WKWebView适配
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/20/iPhone-X主流APP适配情况/" rel="prev" title="iPhone-X主流APP适配情况">
                iPhone-X主流APP适配情况 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Bonway" />
          <p class="site-author-name" itemprop="name">Bonway</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bonway</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
